# Homework 1

**Brandon Boylan-Peck**

<hr>

In this homework, I responded to the questions on class and *No Silver Bullet* by Frederick P. Brook, Jr.

1.  **Essential difficulties** are those difficulties which are inherent in the problem we are trying to solve. By this, I mean that they are a difficulty which can not be “simplified” or “solved” in any easy way. In the case of software engineering, as Brooks has described, some tasks like the ever-changing nature of the hardware software engineers develop for requiring understanding and changes (conformity) to the code itself for this code to work on all machines are challenging in a way that cannot be simplified. These are problems that will always be there, and even through the introduction of many new technologies, strategies, and more, simply will not vanish.
2.  **Accidental difficulties** are difficulties which are caused by insufficient understanding, preparation, or tools, which cause a problem to be much harder than it needs to be. These problems are those that can be solved with the introduction of new technologies or strategies. In the software engineering field, we have had massive jumps in technology, and for example, Brooks talks about “time-sharing.” The essential idea behind this is that at one point, to compile and test your code, the engineers had to go to a specific system that everyone shared, while now, everyone can compile, build, run, etc. all from a terminal from their own machine. This problem wasn’t caused because “software engineering is hard,” but because “technology was still advancing,” therefore, it is a difficulty that is not inherent in the problem, but exists only because of being insufficiently prepared, having the wrong tools, etc.
3.  The four essential difficulties that Brooks described for software engineering are: *Complexity*, *Conformity*, *Changeability*, and *Invisibility*. 
    a.  **Complexity**, as he describes it, is essentially the number of different pieces of the software in general, and how many individual properties, components, etc. they have. As an example, Brooks talks about how every component of a piece of software is different. When you have something that will be used repeatedly, you write a new function, not place the same code here a bunch of times.
    b.  **Conformity**, as he describes it, is the idea that software must be usable on all sorts of platforms, and for that, it must be build such that it can work on all these different things. Even a simple example of this in the modern day, is self-build computers. Every self-built computer does not have the same parts, in fact they often have very different parts. But a computer game must be built to handle this. It cannot simply run only “on this specific computer and no others.” It has to be malleable and be able to “conform” to any and all computer builds.
    c.  **Changeability**, as he describes it, is the idea that software can far outlive its original intended purpose and build target. Software may continue to be used far past entirely new systems, architecture, etc. Or even have new, possible, features pop up. The software must be able to adapt to this and “change.” I already provided a few minor examples, but in the case of a piece of software being able to do a good deal of things, there’s always “more” it could do. some users may need the software to add a feature or two to enhance the product, and for that, the software much change, and adapt.
    d.  **invisibility**, as he describes it, is the idea that software engineering cannot be visualized. The constructs and structures of software are far from being easily visualized. Data structures and functions, can be hard enough for computer scientist to understand. And we have to understand these things in order to develop with them, but a normal client, one who doesn’t know this, will have an incredibly difficult, if not impossible time to even understand them, let alone visualize them.
4.  A **silver bullet** is essentially a singular method or tool that solves “all the problems.” It eliminates the difficulties, simplifies the process, and provides “order-of-magnitude” improvement. Brooks essentially discusses the challenges involved with software engineering, the things that make it hard. He continues to assert that these problems are not possible to simply “solve.” In the case of something like physics, researchers are discovering ways to simplify away the complexities of incredibly difficult problems every day. As we understand more about these things, we can then better simulate and process them. But Brooks states that these complexities of software engineering, things like problem specification for example, are essential to the process itself. They cannot be simplified away and solved for if they are so essential and required by the very task we are attempting to solve.
5.  When it comes to research and development, there are two very different sides. The research sides, the chemists, computer science. And the development side, the chemical engineers, software engineering. Computer science is very much the research side, like chemists, they’re the people who research, study, find the new principles and new ideas. As we discussed in class, an example of this is a chemist who develops a new way to purify salt water into drinkable water. They complete this, write the paper, and they’re done. Computer science is the same field. While on the development side, we have software engineering and the chemical engineers. These are the people that must take that newly written paper and go “okay, how can we do this on an efficient, scalable, and mass producible scale?” they’re the ones who take those papers and make the factories, or the new products. Software engineering, falls right into that category.
6.  On the subject of software engineering, we have, as described in class, several very important terms:
    a.  **Abstractions** – essentially, an abstraction is something that breaks a larger problem into smaller pieces, so it is easier to understand. Examples of abstractions include things like Databases, file systems, a list of tasks even, and more are all abstractions. These abstractions are something done by almost everything software engineers work with, and to solve the jobs they’ve been given, good software engineers must break the big job into smaller ones, and smaller ones, providing abstractions to make the job understandable and completable.
    b.  **Conversations** – Specifically in the case of software engineering, conversations are more than just talking. Sure, talking is a big part of it, communication is always key, but information in general, passed back and forth in some way can serve as a conversation. As we discussed in class, uploading your code to git, then a co-worker changing it a bit, then you modifying it in turn. Or perhaps the passing of code and testing data back and forth, etc. all of these are conversations between your co-workers on a project, and this is something so integral to working on a project within a group.
    c.  **Specification** – specification is very much like “defining,” and like we said in class, software engineers specify nearly everything. But to specify is to define and understand. As software engineers you need to know exactly what the client wants, all the features, options, etc. or else you cannot define and understand the requirements of the job you have. And from there, you need to define all the different ideas and plans for design including code, testing, etc. Specification is incredibly important and challenging.
    d.  **Translation** – this is very literally, the act of changing something from one specification, to another. This can be from language A to language B, it can be bringing code to life from a plan, and more. Coding, is in a way, the very definition of translation. It is translation from a plan on paper, into lines and lines of a completely different language on a screen that now DO things. And of course, that’s only one minor example of the importance of translation in software engineering.
    e.  **Iteration** – the very act of iteration is to do something once, then change what you did a little bit and do it again, then change it a bit more and do it again and so on. Doing one thing and slightly changing it test after test as you work towards the ultimate goal of completion. Writing code is so very inherently iterative. You write a part of the code, then test it. If it doesn’t work perfectly, you change it a bit, and test it some more. This process allows engineers to build upon things and grow code one step at a time.
